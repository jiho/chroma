% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scale_hue.R
\name{hue_scale}
\alias{hue_scale}
\alias{hue_map}
\alias{hue_palette}
\alias{hue_colors}
\alias{scale_color_hue_c}
\alias{scale_colour_hue_c}
\alias{scale_fill_hue_c}
\alias{scale_color_hue_d}
\alias{scale_colour_hue_d}
\alias{scale_fill_hue_d}
\title{Hue scale and palette}
\usage{
hue_scale(
  h = c(0, 360) + 40,
  c = 0.65,
  l = 0.65,
  domain = c(0, 1),
  reverse = FALSE,
  full.circle = FALSE,
  na.value = NULL,
  extrapolate = FALSE
)

hue_map(x, ...)

hue_palette(...)

hue_colors(n, ...)

scale_color_hue_c(
  ...,
  h = c(250, 350),
  c = 0.65,
  l = 0.65,
  reverse = FALSE,
  full.circle = FALSE,
  na.value = NULL,
  guide = "colorbar"
)

scale_fill_hue_c(
  ...,
  h = c(250, 350),
  c = 0.65,
  l = 0.65,
  reverse = FALSE,
  full.circle = FALSE,
  na.value = NULL,
  guide = "colorbar"
)

scale_color_hue_d(
  ...,
  h = c(0, 360) + 40,
  c = 0.65,
  l = 0.65,
  reverse = FALSE,
  full.circle = FALSE,
  na.value = NULL,
  guide = "legend"
)

scale_fill_hue_d(
  ...,
  h = c(0, 360) + 40,
  c = 0.65,
  l = 0.65,
  reverse = FALSE,
  full.circle = FALSE,
  na.value = NULL,
  guide = "legend"
)
}
\arguments{
\item{h}{range of hues to use, a vector of length 2 with either angles around the color wheel, in \code{[0,360]} (angles outside of the range are rotated back to within \code{[0,360]}: 380 = 20, -15 = 345, etc.), or colors (hex or named) from which the hue is extracted (by function \code{\link{hue}}).}

\item{c}{chromacity, number in \code{[0,~1]}; 0 is grey, ~1 is full color.}

\item{l}{lightness, number in \code{[0,1]}; 0 is darkest, 1 is brightest.}

\item{domain}{vector of two values between which the scale is computed.}

\item{reverse}{whether to reverse the order of colors along the scale.}

\item{full.circle}{when the range of hues specified in \code{h} spans 360°, this argument determines if the color scale should also span the full circle (which results in the same color being associated with different values, at the extremes of the scale), or not. By default it is set to FALSE to avoid this caveat. When \code{h} does not span 360°, this argument is ignored because the caveat disappears.}

\item{na.value}{value to return for missing values in the input. Can be either a color, \code{NULL} in which case a tentitatively appropriate color will be chosen automatically, or \code{NA}.}

\item{extrapolate}{when \code{FALSE}, the default, return \code{NA} for input values that are out of the domain; when \code{TRUE} return the color corresponding to the extreme of the domain instead.}

\item{x}{a vector whose values will be coerced to numbers and mapped to colors.}

\item{...}{passed to \code{\link{hue_scale}} from other \code{hue_*} functions; passed to \code{ggplot2::\link[ggplot2]{continuous_scale}} or \code{ggplot2::\link[ggplot2]{discrete_scale}} from the \code{scale_*} functions, as appropriate. NB: in all situations, passing \code{domain} is meaningless and yields an error.}

\item{n}{number of colors to extract from the color palette.}

\item{guide}{type of guide for the legend ("colorbar" for a continuous colorbar, "legend" for a categorical guide) or guide object itself.}
}
\value{
\code{*_scale} returns a \strong{function}. This function takes a single argument (\code{x}: a numeric vector), maps its values to colors, and returns thee colors as hex codes.

\code{*_map} is a shortcut for \code{*_scale(domain=range(x))(x)}: it creates a scale that spans the range of values in argument \code{x}, maps the content of \code{x} on that scale, and returns the \strong{colors}.

\code{*_palette} returns a \strong{function}. This function takes an integer (\code{n}) as argument, picks \code{n} colors evenly spaced along the scale, and returns them as hex codes.

\code{*_colors} is a shortcut for \code{*_palette()(n)} and directly returns \code{n} evenly spaced \strong{colors}. It is equivalent to built-in functions such as \code{\link[grDevices]{heat.colors}}, \code{\link[grDevices]{topo.colors}}, etc.

\code{scale_*} return a \strong{ggplot2 scale}, either discrete (similar to \code{\link[ggplot2]{scale_color_discrete}}) or continuous (similar to \code{\link[ggplot2]{scale_color_continuous}}).
}
\description{
Hue-based color scale, in HCL space.
}
\details{
In HCL space, the perceived color (hue) is completely separated from the perceived intensity (chromacity) and lightness of the color. This means that colors of various hues but same chromacity and lightness appear as the exact same grey when converted to greyscale. This makes the HCL space particularly suitable to create good color palettes:
\itemize{
  \item For qualitative palettes (discrete variables): varying \code{h} at constant \code{c} and \code{l} avoids drawing attention to certain hues, as would happen if the same was done in HSV or HSL space. Indeed, some hues are perceived as brighter (yellow, light green, etc.), others as duller/darker (blues, etc.).
  \item For sequential palettes (continuous variables): varying \code{l} (or possibly \code{c}) for a constant \code{h} gives a sense of direction and avoid the many perceptual pitfalls typical of 'rainbow'-like scales.
}
}
\examples{
# Display the full hue range with
x <- 0:360
plot(x, rep(0,length(x)), col=hue_map(x, h=c(0,360), full.circle=TRUE), ylab="", pch="|", cex=5)

# Define a perceptually-correct "rainbow"-like scale function
rainbow_scale <- hue_scale()
# and apply it to some data
show_col(rainbow_scale(x=c(0, 0.2, 0.6, 1)))

# Define a palette function
# (which works like the actual rainbow() function)
rainbow_pal <- hue_palette()
# and get 10 colors from it
rainbow_pal(n=10)
show_col(rainbow_pal(n=10))
# or use the shortcut
hue_colors(n=50)
show_col(hue_colors(n=50))

# Palettes of varying hue but constant chromacity and lightness
# are appropriate to distinguish among levels of a qualitative variable
attach(iris)
plot(Petal.Length, Petal.Width, col=hue_map(Species), pch=19)
legend(1, 2, legend=levels(Species), col=hue_colors(n=nlevels(Species)), pch=19)

# Let us try with a quantitative variable
image(maunga, col=hue_colors(100))
# = typical rainbow scale bullseye effect, yuk!
# but, with a limited hue range, they can be OK
image(maunga, col=hue_colors(10, h=c(170, 90), l=0.6))
contour(maunga, col=alpha("white", 0.5), add=TRUE)

persp(maunga, theta=50, phi=25, scale=FALSE, expand=2,
      border=alpha("black", 0.4),
      col=hue_map(persp_facets(maunga$z), h=c(170, 90), l=0.6))
# Still, lightness (or chromacity) based scales are likely to be better...

# To create a legend for a continuous variable, we need to define the
# scale with its domain and then use it for both the plot and the legend.
attach(airquality)
oz_scale <- hue_scale(h=c(250,350), l=0.5, domain=range(Ozone, na.rm=TRUE))
plot(Wind, Temp, col=oz_scale(Ozone), pch=19)
legend(17, 95, legend=pretty(Ozone), col=oz_scale(pretty(Ozone)), pch=19)

# Note how the missing value grey matches the rest of the colors on the scale
plot(Wind, Temp, col=hue_map(Ozone, h=c(250,350), l=0.5), pch=19)
plot(Wind, Temp, col=hue_map(Ozone, h=c(250,350), l=0.8), pch=19)
plot(Wind, Temp, col=hue_map(Ozone, h=c(250,350), l=0.3), pch=19)

# Make the plot nicer to read by putting the legend on the side
pars <- sidemargin()
plot(Wind, Temp, col=oz_scale(Ozone), pch=19)
sidelegend(legend=pretty(Ozone), col=oz_scale(pretty(Ozone)), pch=19)
par(pars)

\dontrun{
# or just use ggplot2
library("ggplot2")
ggplot(iris) +
  geom_point(aes(x=Petal.Length, y=Petal.Width, color=Species)) +
  scale_color_hue_d()
ggplot(airquality) +
  geom_point(aes(x=Wind, y=Temp, color=Ozone)) +
  scale_color_hue_c()}
}
\seealso{
The \code{\link{hcl}} function, on which this one is based.

Other HCL-based scales: 
\code{\link{chroma_scale}()},
\code{\link{light_scale}()},
\code{\link{vsup_scale}()}

Other color scales and palettes: 
\code{\link{brewer_scale}()},
\code{\link{chroma_scale}()},
\code{\link{cubehelix_scale}()},
\code{\link{etopo_scale}()},
\code{\link{inferno_scale}()},
\code{\link{interp_scale}()},
\code{\link{light_scale}()},
\code{\link{magma_scale}()},
\code{\link{plasma_scale}()},
\code{\link{turbo_scale}()},
\code{\link{viridis_scale}()},
\code{\link{vsup_scale}()},
\code{\link{wikitopo_scale}()}
}
\concept{HCL-based scales}
\concept{color scales and palettes}
