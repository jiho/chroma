% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scale_chroma.R
\name{chroma_scale}
\alias{chroma_scale}
\alias{chroma_map}
\alias{chroma_palette}
\alias{chroma_colors}
\alias{scale_color_chroma}
\alias{scale_colour_chroma}
\alias{scale_fill_chroma}
\title{Chromacity scale and palette}
\usage{
chroma_scale(
  chroma = c(0, 1),
  l = 0.5,
  h = 0,
  domain = c(0, 1),
  reverse = FALSE,
  na.value = NULL,
  extrapolate = FALSE
)

chroma_map(x, ...)

chroma_palette(...)

chroma_colors(n, ...)

scale_color_chroma(
  ...,
  chroma = c(0, 1),
  l = 0.5,
  h = 0,
  reverse = FALSE,
  na.value = NULL,
  guide = "colorbar"
)

scale_fill_chroma(
  ...,
  chroma = c(0, 1),
  l = 0.5,
  h = 0,
  reverse = FALSE,
  na.value = NULL,
  guide = "colorbar"
)
}
\arguments{
\item{chroma}{chromacity, vector of two numbers in \code{[0,~1]} (0 is grey, ~1 is full color) giving the minimum and maximum chromacities along the scale.}

\item{l}{lightness, number in \code{[0,1]}; 0 is darkest, 1 is brightest.}

\item{h}{hue, either an angle around the color wheel, in [0,360] (angles outside of the range are rotated back to within [0, 360]: 380 = 20, -15 = 345, etc.), or a color (hex or named) from which the hue is extracted (by function \code{\link{hue}}).}

\item{domain}{vector of two values between which the scale is computed.}

\item{reverse}{whether to reverse the order of colors along the scale.}

\item{na.value}{value to return for missing values in the input. Can be either a color, \code{NULL} in which case a tentitatively appropriate color will be chosen automatically, or \code{NA}.}

\item{extrapolate}{when \code{FALSE}, the default, return \code{NA} for input values that are out of the domain; when \code{TRUE} return the color corresponding to the extreme of the domain instead.}

\item{x}{a vector whose values will be coerced to numbers and mapped to colors.}

\item{...}{passed to \code{\link{chroma_scale}} from other \code{chroma_*} functions; passed to \code{ggplot2::\link[ggplot2]{continuous_scale}} from the \code{scale_*} functions. NB: in all situations, passing \code{domain} is meaningless and yields an error.}

\item{n}{number of colors to extract from the color palette.}

\item{guide}{type of guide for the legend ("colorbar" for a continuous colorbar, "legend" for a categorical guide) or guide object itself.}
}
\value{
\code{*_scale} returns a \strong{function}. This function takes a single argument (\code{x}: a numeric vector), maps its values to colors, and returns thee colors as hex codes.

\code{*_map} is a shortcut for \code{*_scale(domain=range(x))(x)}: it creates a scale that spans the range of values in argument \code{x}, maps the content of \code{x} on that scale, and returns the \strong{colors}.

\code{*_palette} returns a \strong{function}. This function takes an integer (\code{n}) as argument, picks \code{n} colors evenly spaced along the scale, and returns them as hex codes.

\code{*_colors} is a shortcut for \code{*_palette()(n)} and directly returns \code{n} evenly spaced \strong{colors}. It is equivalent to built-in functions such as \code{\link[grDevices]{heat.colors}}, \code{\link[grDevices]{topo.colors}}, etc.

\code{scale_*} return a \strong{ggplot2 scale}, either discrete (similar to \code{\link[ggplot2]{scale_color_discrete}}) or continuous (similar to \code{\link[ggplot2]{scale_color_continuous}}).
}
\description{
Chromacity-based color scale, in HCL space.
}
\details{
In HCL space, the perceived color (hue) is completely separated from the perceived intensity (chromacity) and lightness of the color. This means that colors of various hues but same chromacity and lightness appear as the exact same grey when converted to greyscale. This makes the HCL space particularly suitable to create good color palettes:
\itemize{
  \item For qualitative palettes (discrete variables): varying \code{h} at constant \code{c} and \code{l} avoids drawing attention to certain hues, as would happen if the same was done in HSV or HSL space. Indeed, some hues are perceived as brighter (yellow, light green, etc.), others as duller/darker (blues, etc.).
  \item For sequential palettes (continuous variables): varying \code{l} (or possibly \code{c}) for a constant \code{h} gives a sense of direction and avoid the many perceptual pitfalls typical of 'rainbow'-like scales.
}
}
\examples{
# Define a scale towards a more intense red
reds <- chroma_scale(h=30)
# and apply it to some data
reds(x=c(0, 0.2, 0.6, 1))
show_col(reds(x=c(0, 0.2, 0.6, 1)))

# Define a palette function
reds_pal <- chroma_palette(h=30)
# and get 10 colors from it
reds_pal(n=10)
show_col(reds_pal(n=10))
# or use the shortcut and get 50 colors
show_col(chroma_colors(n=50, h=30))

# Determine hue from a color and then define a chroma scale
blues <- chroma_colors(n=50, h="dodgerblue")
greens <- chroma_colors(n=50, h="green")
golds <- chroma_colors(n=50, h="gold")
pinks <- chroma_colors(n=50, h="deeppink")
show_col(blues, greens, golds, pinks)

# Chroma scales can be used for continuous variables
# such as the elevation of the Maunga Whau volcano
image(maunga, col=chroma_colors(100, h="orange"))
contour(maunga, col=alpha("white", 0.5), add=TRUE)

filled.contour(maunga, color.palette=chroma_palette(h="orange"))

persp(maunga, theta=50, phi=25, scale=FALSE, expand=2,
      border=alpha("black", 0.4),
      col=chroma_map(persp_facets(maunga$z), h="orange"))
# but a lightness-based scale would probably be even better
# (see ?light_scale)

\dontrun{
# in spinning 3D
library("rgl")
persp3d(maunga, aspect=c(1,0.7,0.2), axes=FALSE, box=FALSE,
        col=chroma_map(maunga$z, h="orange"))
play3d(spin3d(axis=c(0, 0, 1), rpm=10), duration=6)

# and with ggplot2
library("ggplot2")
ggplot(maungaxyz) + coord_fixed() +
  geom_raster(aes(x=x, y=y, fill=z)) +
  geom_contour(aes(x=x, y=y, z=z), color="white", alpha=0.5) +
  scale_fill_chroma(h="orange")
}

# Or they could be used to map a third variable on a scatterplot
attach(airquality)
# define a scale encompassing the whole data
blue_scale <- chroma_scale(h="cornflowerblue", domain=c(0,200))
# use it on a plot and in the legend
pars <- sidemargin()
plot(Wind, Temp, col=blue_scale(Ozone), pch=19)
sidelegend(legend=c(pretty(Ozone), "NA"),
           col=blue_scale(c(pretty(Ozone), NA)), pch=19)
par(pars)
# note that the missing value color contrasts with the rest of the scale

# They are not really appropriate for categorical variables though
attach(iris)
plot(Petal.Length, Petal.Width, col=chroma_map(Species), pch=19)
legend(1, 2, legend=levels(Species),
             col=chroma_colors(n=nlevels(Species)), pch=19)
# a hue-based scale would be much better (see ?hue_scale)
}
\seealso{
The \code{\link{hcl}} function, on which this one is based.

Other HCL-based scales: 
\code{\link{hue_scale}()},
\code{\link{light_scale}()}

Other color scales and palettes: 
\code{\link{brewer_scale}()},
\code{\link{cubehelix_scale}()},
\code{\link{etopo_scale}()},
\code{\link{hue_scale}()},
\code{\link{inferno_scale}()},
\code{\link{interp_scale}()},
\code{\link{light_scale}()},
\code{\link{magma_scale}()},
\code{\link{plasma_scale}()},
\code{\link{turbo_scale}()},
\code{\link{viridis_scale}()},
\code{\link{wikitopo_scale}()}
}
\concept{HCL-based scales}
\concept{color scales and palettes}
